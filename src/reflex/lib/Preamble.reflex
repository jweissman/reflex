/*
 * class Object
 * The class of everything!
 */
class Object
    def neq other
      self.eq(other).negate()
    end

    isA(klass) { self.isInstanceOf(klass) }
    nil() { false }
    true() { true }
    false() { Boolean.negate(self.true()) }
    toString() { self.inspect() }
end

/*
 * Class
 *
 * The class of classes.
 */
class Class
    def isDescendantOf(other)
      other.isAncestorOf(self)
    end

    isKindOf(other) { other == self || other.isAncestorOf(self) }
    auto(&b) { meta.instanceEval(b) }
    include(mod) { mod.inject(self) }
end

/**
 * Function
 *
 * The class of functions.
 */
class Function {
    meta.instanceEval { new(fn) { fn } }
    call() { self() }
}

/* 
 * Nihil
 *
 * The class of uninhabited types.
 */
class Nihil {
    nil() { true }
    true() { false }
}

/*
 * Boolean
 * 
 * The class of truth-values.
 */
class Boolean {
    eq(other) { self.isInstanceOf(other.class) }
    negate() { Boolean.negate(self) }
    meta.instanceEval {
        negate(value) {
            if (value.true()) { false } else { true }
        }
    }
}

class Truth < Boolean {
    negate() { false }
}

class Falsity < Boolean {
    true() { false }
    negate() { true }
}

/*
 * Number
 * 
 * The class of numeric values
 */
class Number {
    zero() { self == 0 }
    one() { self == 1 }
    positive() { self.gt(0) }
    true() { self.zero().negate() }
    divide(other) {
        if (other.zero()) {
            if (self.zero()) {
                Indeterminate.new()
            } else {
                if (self.positive()) {
                    PositiveApeiron.new()
                } else {
                    NegativeApeiron.new()
                }
            }
        } else {
            self.rawDiv(other)
        }
    }

    times(&timesBlock) {
        puts self + ".times"
        if (self<=0) { [] }
        else {
          r = 0.upto(self-1)
          it = RangeIterator.new(r)
          if (block_given) {
              puts self + ".times -- block given, enumerating"
              it = it.map(&timesBlock)
          }
          it.collect()
        }
    }

    upto(stop,&block) {
        r=Range.new(self, stop)
        if (block_given) {
            r.each(&block) 
        }
        r
    }
    // really just alias
    downto(stop,&block) { self.upto(stop,&block) if block_given else self.upto(stop) }
}

class Integer < Number {}
class Float < Number {}
class Indeterminate < Number {}
class Apeiron < Number {
    add(other) { self }
    subtract(other) { self }
    multiply(other) { self }
    divide(other) { self }
}
class PositiveApeiron < Apeiron { negate() { NegativeApeiron.new() } }
class NegativeApeiron < Apeiron { negate() { PositiveApeiron.new() } }

/// enumerability /////

class Module {
    inject(target) { Kernel.include(self, target) }
}

module Enumerable {

    // 'hard eval' def which falls back to toArray...
    // with yield semantics this could be more efficient!
    each(&eachBlock) {
        if (block_given) { self.toArray().each(&eachBlock) }
        else { self.toArray().each() }
    }

    map(&mapFn) { self.each().map(&mapFn).collect() }
    collect() { self.each().collect() }
    first() { self.collect().first() }
    last() { self.collect().last() }
    rest() { self.collect().rest() }
    size() { self.collect().length() }
    // sample() { self.collect().sample()}
    reverse() { self.collect().reverse() }
    includes(v) { self.collect().includes(v) }
    select(&b) { self.collect().select(&b) }

    detect(&b) { self.each().detect(&b) }
    any(&b) { self.each().any(&b) }
    zip(&b) { self.each().zip(&b) }

    join(delim) { self.collect().join(delim) }
    withIndex(&b) {
        puts "Enumerable.withIndex"
        if (block_given) {
         self.each().withIndex(&b)
        } else {
         self.each().withIndex()
        }
    }
    eachWithIndex(&b) {
       puts "Enumerable.eachWithIndex"
       if (block_given) {
         self.each().withIndex(&b)
       } else {
         self.each().withIndex()
       }
    }

    sample() {
        self.collect().get(Kernel.rand(self.size()-1))
    }
}

class Iterator {
    include Enumerable
    init(indexed) {
        self.index = 0;
        self.exhausted = false;
    }

    withIndex(&b) {
       puts "Iterator.withIndex"
       enum = Enumerator.new(self).withIndex()
       if (block_given) {
           puts "Iterator.withIndex --- got block! running..."
          enum(&b)
       }
       enum
    }

    next() {
        if (!self.isExhausted()) {
            val=self.curr()
            self.advance()
            val
        } else {
            fail 'stop iteration'
        }
    }

    curr() { fail "Implement Iterator#curr in " + self.class }
    isExhausted() { self.exhausted }
    call(&block) {
        if (block_given) {
            // self.map(&block).collect()
            iteratee = []
            until (self.isExhausted()) {
                n = self.next()
                if (n.isA(Unpack)) {
                    iteratee.push block(...n.val)
                } else {
                    iteratee.push block(n)
                }
            }
            iteratee
        } else {
            self
        }
        
    }
    toArray() {
        arr=[]
        self { |i| arr.push(i) }
        arr
    }
}

class ArrayIterator < Iterator {
    init(arr) {
        self.array = arr
        super.init()
    }

    advance() {
        self.index = self.index + 1;
        if (self.isExhausted()) { //self.index >= self.array.length()) {
            self.exhausted = true;
        }
    }

    isExhausted() { self.index >= self.array.length() }

    curr() {
        if (self.isExhausted()) {
          nil
        } else {
          self.array.get(self.index)
        }
    }
}

class RangeIterator < Iterator {
    init(range) {
        super.init()
        self.range = range;
        self.index = range.start;
    }

    advance() {
        step = range.inc * range.dir
        self.index = self.index + step;
        if (range.dir == 1 && self.index > range.stop) {
            self.exhausted = true;
        }
        if (range.dir == -1 && self.index < range.stop) {
            self.exhausted = true;
        }
    }

    curr() { self.index }
}

// tiny wrapper so we can identify withIndex-style things that should be destructured
class Unpack { init(val) { self.val = val } }
class Enumerator {
    include Enumerable
    init(it) {
        self.it = it
    }

    map(&fn) {
       MappedEnumerator.new(self, fn)
    }

    withIndex(&pointBlock) {
        puts "Enumerator.withIndex"
        index_space = (0..Infinity).each()
        point = e => { 
           i = index_space.next()
           res = Unpack.new([e, i])
           res
       }
       mappedEnum = MappedEnumerator.new(self, point, true)
       if (block_given) {
         mappedEnum.each(&pointBlock)
       } else {
         mappedEnum.collect()
       }
    }

    each(&b) { if (block_given) { self.call(&b) }; self }
    next() {
        // if (!self.isExhausted()) {
        self.it.next()
        // }
    }
    call(&b) {
        self.tilExhausted(&b)
    }
    collect() {
        collected=[]
        // self.tilExhausted { |v|
        until (self.isExhausted()) {
            v = self.next()
            if (v.isA(Unpack)) {
                collected.push v.val // = collected + v.val
            } else {
                collected.push v
            }
        }
        collected
    }
    

    any(&pred) {
        matched = false
        until (self.isExhausted() || matched) {
            elem = self.next()
            if (elem.isA(Unpack)) {
                matched = pred(...elem.val)
            } else {
                matched = pred(elem)
            }
        }
        matched
    }
    detect(&pred) {
        matched = false
        detected = nil
        until (self.isExhausted() || matched) {
            elem = self.next()
            if (elem.isA(Unpack)) {
              matched = pred(...elem.val)
              if (matched) {
                  detected = elem.val
              }
            } else {
              matched = pred(elem)
              if (matched) {
                  detected = elem
              }
            }
        }
        detected
    }
    toArray() { self.collect() }
    isExhausted() { self.it.isExhausted() }
    tilExhausted(&block) {
        until (self.isExhausted()) {
            n = self.next()
            if (n.isA(Unpack)) {
                block(...n.val)
            } else {
                block(n)
            }
        }
    }
    length() { self.collect().length() }
}


class MappedEnumerator < Enumerator {
    init(underylingEnum, mapFn, destructure) {
        self.underlyingEnum = underylingEnum
        self.mapFn = mapFn
        self.destructure = destructure || false
        super.init(underylingEnum.it)
    }
    isExhausted() { self.underlyingEnum.isExhausted() }
    next() {
        n = self.underlyingEnum.next()
        if (n.isA(Unpack)) {
            Unpack.new(self.mapFn(...n.val)) //self.underlyingEnum.next())
        } else {
            self.mapFn(n)
        }
    }
    inspect() { "MappedEnum["+mapFn+" over " +underlyingEnum.inspect() +"]"}
}


/**
 * Array
 *
 * The class of object-valued index spaces.
 */
class Array {
    include Enumerable

    push(item) { self.set(self.length(), item); self }
    add(other) { self.concat(other) }
    includes(item) { self.any { |e| e == item } }
    subtract(other) { self.select { |e| !other.includes(e) } }

    multiply(num) {
        if (num.isA(Number)) {
            n = num.toInteger()
            i = self
            n.times { i }.collect()
        } else {
            fail "won't multiply array by non-numeric"
        }
    }

    eq(other) { 
        isEq = self.length() == other.length()
        if (isEq) {
            self.eachWithIndex { |x, i|
                if (x != other.get(i)) {
                    isEq = false 
                }
            }
        }
        isEq
    }

    toArray() { self }

    each(&b) {
        it = ArrayIterator.new(self)
        enum = Enumerator.new(it)
        if (block_given) { enum(&b) }
        enum
    }
    
    split(sep, &blk) {
        groups = [];
        fragment = [];
        i = 0;
        delim = if block_given then blk else sep.eq 
        while (i <= self.length()-1) {
            e = self.get(i);
            if (delim(e)) {
                if (fragment.length() > 0) {
                    groups.push(fragment)
                    fragment=[]
                }
            } else {
                fragment.push(e)
            }
            i=i+1
        }
        if (fragment.length() > 0) {
            groups.push(fragment)
            fragment=[]
        }
        groups
    }

    first() { self.get(0) }
    last() { self.get(self.length()-1) }
    rest() {
        rst=[]
        1.upto(self.length()-1) { |i| rst.push(self.get(i)) }
        rst
    }

    // select(&b) { self.each().select(&b) }
    detect(&b) { self.each().detect(&b) }
    any(&b) { self.each().any(&b) }
    sample() {
        self.get(Kernel.rand(self.length()-1))
    }

    select(&selectBlock) {
        selected=[]
        // self.tilExhausted do |v|
        //until (self.isExhausted()) {
        self.each { |v|
            // v = self.next()
            // if (v.isA(Unpack)) {
              if (selectBlock(v)) {
                  selected.push(v)
              }
            
        }
        selected
    }

    reverse() {
        len = self.length()
        rev=[]
        1.upto(len) { |i| rev.push(self.get(len-i)) }
        rev
    }

    inject(&fn) {
        res = self.first()
        apply = e => {
            partial = fn(res, e)
            res = partial
        }
        self.rest().each &apply
        res
    }

    join(delim) {
        if (self.length() > 1) {
          d=delim||''
          sum = (a,b) => { a+d+b }
          self.inject &sum
        } else { self.get(0) }
    }

    
}


/**
 * String
 *
 * The class of words
 */
class String {
    include Enumerable
    split(delim) {
        chars = self.toArray()
        if (delim.nil() || delim == '') {
            chars
        } else {
            groups = chars.split(delim)
            groups.map { |letters| letters.join() }.collect()
        }
    }

    toString() { self }
    get(i) { self.split('').get(i) }

    add(other) { self.concat(other) }
    reverse() { self.collect().reverse().join() }
    isPalindrome() { self.reverse() == self }
    multiply(other) {
        if (other.isInstanceOf(Number)) {
            str = self
            other.times { str }.collect().join('')
        } else {
            fail "won't multiply string with non-numeric"
        }
    }
}

/**
 * Range
 * The class of bounded natural intervals.
 */
class Range {
    include Enumerable
    init(start,stop) {
        self.start=start;
        self.stop=stop;
        self.inc=1;
        self.dir=self.start<self.stop?1:-1;
    }
    length() { stop - start }
    inspect() { start + ".." + stop }
    step(i) { self.inc=i; self }
    each(&b) {
        it = RangeIterator.new(self)
        enum = Enumerator.new(it)
        if (block_given) { enum(&b) }
        else { enum }
    }
    reverse() { Range.new(self.stop,self.start) }
    toArray() { self.collect() }
    call(&block) { self.map(&block) }
    detect(&b) { self.each().detect(&b) }
    any(&b) { self.each().any(&b) }
    sample() {
        if (self.inc == 1) {
          self.start + Kernel.rand(self.stop-self.start)
        } else {
            self.toArray().sample()
        }
    }
}

/////

# the universal constants
nil = Nihil.new()
true = Truth.new()
false = Falsity.new()
Infinity = PositiveApeiron.new()
NegativeInfinity = NegativeApeiron.new()


using = Kernel.import
prints = Kernel.println
fail = Kernel.throw
//include = Kernel.include
noop = ->{}

// old ways die hard
require = Kernel.import
puts = o=>Kernel.println(o.toString())

// wire up main so it can define instance methods on itself...
self.defineMethod = meta.defineMethod