/*
 * class Object
 * The class of everything!
 */
class Object {
    neq(other) { self.eq(other).negate() }
    isA(klass) { self.isInstanceOf(klass) }
    nil() { false }
    true() { true }
    false() { Boolean.negate(self.true()) }
}

/*
 * Class
 *
 * The class of classes.
 */
class Class {
    isDescendantOf(other) { other.isAncestorOf(self) }
    isKindOf(other) { other == self || other.isAncestorOf(self) }
    auto(&blk) { meta.instanceEval(&blk) }
}

/**
 * Function
 *
 * The class of functions.
 */
class Function {
    meta.instanceEval { new(fn) { fn } }
    call() { self() }
}

/* 
 * Nihil
 *
 * The class of uninhabited types.
 */
class Nihil {
    nil() { true }
    true() { false }
}

/*
 * Boolean
 * 
 * The class of truth-values.
 */
class Boolean {
    eq(other) { self.isInstanceOf(other.class) }
    negate() { Boolean.negate(self) }
    meta.instanceEval {
        negate(value) {
            if (value.true()) { false } else { true }
        }
    }
}

class Truth < Boolean {
    negate() { false }
}

class Falsity < Boolean {
    true() { false }
    negate() { true }
}

/*
 * Number
 * 
 * The class of numeric values
 */
class Number {
    zero() { self == 0 }
    one() { self == 1 }
    positive() { self.gt(0) }
    true() { self.zero().negate() }
    divide(other) {
        if (other.zero()) {
            if (self.zero()) {
                Indeterminate.new()
            } else {
                if (self.positive()) {
                    PositiveApeiron.new()
                } else {
                    NegativeApeiron.new()
                }
            }
        } else {
            self.rawDiv(other)
        }
    }

    times(&timesBlock) {
        counter = self;
        until (counter.zero()) {
            counter = counter - 1;
            timesBlock()
        }
    }

    upto(stop,&block) {
        r=Range.new(self, stop)
        r.each(&block) if block_given
        r
    }
}

class Integer < Number {}
class Float < Number {}
class Indeterminate < Number {}
class Apeiron < Number {
    add(other) { self }
    subtract(other) { self }
    multiply(other) { self }
    divide(other) { self }
}
class PositiveApeiron < Apeiron { negate() { NegativeApeiron.new() } }
class NegativeApeiron < Apeiron { negate() { PositiveApeiron.new() } }

/**
 * Array
 *
 * The class of object-valued index spaces.
 */
class Array {
    push(it) {
        self.set(self.length(), it)
        self
    }

    add(other) {
        self.concat(other)
    }

    each(&eachBlock) {
        i = 0;
        while (i <= self.length()-1) {
            val = self.get(i)
           eachBlock(val); //self.get(i));
           i = i + 1
        }
    }
    
    eachWithIndex(&eachBlock) {
        i = 0;
        while (i <= self.length()-1) {
           eachBlock(self.get(i), i);
           i = i + 1
        }
    }

    split(sep, &blk) {
        groups = [];
        fragment = [];
        i = 0;
        delim = if block_given then blk else sep.eq 
        while (i <= self.length()-1) {
            e = self.get(i);
            if (delim(e)) {
                if (fragment.length() > 0) {
                    groups.push(fragment)
                    fragment=[]
                }
            } else {
                fragment.push(e)
            }
            i=i+1
        }
        if (fragment.length() > 0) {
            groups.push(fragment)
            fragment=[]
        }
        groups
    }

    map(&mapFn) {
        res = Array.new()
        index=0
        self.each { |e|
            mapped = mapFn(e)
            res.set(index, mapped);
            index=index+1
        }
        res
    }

    first() { self.get(0) }
    rest() {
        rst=[]
        1.upto(self.length()-1) { |i| rst.push(self.get(i)) }
        rst
    }

    reverse() {
        if (self.length().zero()) { [] }
        else {
            self.rest().reverse() + [self.first()]
        }
    }

    inject(&fn) {
        res = self.first()
        apply = e => {
            partial = fn(res, e)
            res = partial
        }
        self.rest().each &apply
        res
    }

    join(delim) {
        // d=delim||''
        sum = (a,b) => { a+b }
        self.inject &sum
    }
}


/**
 * String
 *
 * The class of words
 */
class String {
    split(delim) {
        chars = self.toArray()
        if (delim.nil() || delim == '') {
            chars
        } else {
            groups = chars.split(delim)
            groups.map { |letters| letters.join() }
        }
    }

    get(i) { self.toArray().get(i) }

    add(other) { self.concat(other) }
    multiply(other) {
        if (other.isInstanceOf(Number)) {
            res = ''
            other.times { res = res + self }
            res
        } else {
            fail "won't multiply string with non-numeric"
        }
    }
}

/**
 * Range
 * The class of bounded natural intervals.
 */
class Range {
    init(start,stop) { self.start=start; self.stop=stop; self.inc=1 }
    inspect() { start + ".." + stop }
    step(i) { self.inc=i; self }
    toArray() {
        arr = []
        i = self.start;
        while (i <= self.stop) {
           arr.push(i)
           i = i + self.inc
        }
        arr
    }
    each(&eachBlock) { self.toArray().each(&eachBlock) }
    map(&mapFn) { self.toArray().map(&mapFn) }
    call(&block) { self.each(&block) }
}

# the universal constants
nil = Nihil.new()
true = Truth.new()
false = Falsity.new()
Infinity = PositiveApeiron.new()
NegativeInfinity = NegativeApeiron.new()

using = Kernel.import
prints = Kernel.println
fail = Kernel.throw
noop = ->{}

// old ways die hard
require = Kernel.import
puts = Kernel.println

// wire up main so it can define instance methods on itself...
self.defineMethod = meta.defineMethod